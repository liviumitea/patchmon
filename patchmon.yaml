apiVersion: v1
kind: Namespace
metadata:
  name: patchmon
---
apiVersion: v1
kind: Secret
metadata:
  name: patchmon-db-secret
  namespace: patchmon
type: Opaque
stringData:
  POSTGRES_DB: patchmon_db
  POSTGRES_USER: patchmon_user
  POSTGRES_PASSWORD: "Password"
  DATABASE_URL: postgresql://patchmon_user:Password@patchmon-postgres:5432/patchmon_db
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: patchmon-config
  namespace: patchmon
data:
  LOG_LEVEL: "info"
  SERVER_PROTOCOL: "http"
  SERVER_HOST: "0.0.0.0"
  SERVER_PORT: "3001"
  CORS_ORIGIN: "http://172.16.23.39"
  PM_DB_CONN_MAX_ATTEMPTS: "30"
  PM_DB_CONN_WAIT_INTERVAL: "2"
  RATE_LIMIT_WINDOW_MS: "900000"
  RATE_LIMIT_MAX: "100"
---
# Agent scripts â€“ make install endpoint work even if seeding is skipped
apiVersion: v1
kind: ConfigMap
metadata:
  name: patchmon-agent-scripts
  namespace: patchmon
data:
  patchmon-agent.sh: |
    #!/usr/bin/env sh
    echo "PatchMon agent placeholder (linux). Replace with real script."
  patchmon-agent.ps1: |
    Write-Output "PatchMon agent placeholder (windows). Replace with real script."
---
# Bind to your EXISTING Longhorn PV for Postgres
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: patchmon-db-pvc
  namespace: patchmon
spec:
  accessModes: ["ReadWriteOnce"]
  resources:
    requests:
      storage: 5Gi
  volumeName: patchmon-db-pv          # <-- existing PV name (your Longhorn volume)
---
# Bind to your EXISTING Longhorn PV for AGENTS (separate from DB!)
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: patchmon-agents-pvc
  namespace: patchmon
spec:
  accessModes: ["ReadWriteOnce"]
  resources:
    requests:
      storage: 5Gi
  volumeName: patchmon-bk-pv      # <-- replace with your agents PV name
---
# Postgres
apiVersion: v1
kind: Service
metadata:
  name: patchmon-postgres
  namespace: patchmon
spec:
  clusterIP: None
  ports:
    - name: pg
      port: 5432
  selector:
    app: patchmon-postgres
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: patchmon-postgres
  namespace: patchmon
spec:
  serviceName: patchmon-postgres
  replicas: 1
  selector:
    matchLabels:
      app: patchmon-postgres
  template:
    metadata:
      labels:
        app: patchmon-postgres
    spec:
      securityContext:
        fsGroup: 999
        fsGroupChangePolicy: "OnRootMismatch"
      containers:
        - name: postgres
          image: postgres:17-alpine
          env:
            - name: POSTGRES_DB
              valueFrom: {secretKeyRef: {name: patchmon-db-secret, key: POSTGRES_DB}}
            - name: POSTGRES_USER
              valueFrom: {secretKeyRef: {name: patchmon-db-secret, key: POSTGRES_USER}}
            - name: POSTGRES_PASSWORD
              valueFrom: {secretKeyRef: {name: patchmon-db-secret, key: POSTGRES_PASSWORD}}
          ports:
            - containerPort: 5432
          volumeMounts:
            - name: data
              mountPath: /var/lib/postgresql/data
              subPath: pgdata        # clean subfolder (avoids lost+found)
          livenessProbe:
            exec:
              command: ["sh","-c","pg_isready -U \"$POSTGRES_USER\" -d \"$POSTGRES_DB\""]
            initialDelaySeconds: 10
            periodSeconds: 10
          readinessProbe:
            exec:
              command: ["sh","-c","pg_isready -U \"$POSTGRES_USER\" -d \"$POSTGRES_DB\""]
            initialDelaySeconds: 5
            periodSeconds: 5
      volumes:
        - name: data
          persistentVolumeClaim:
            claimName: patchmon-db-pvc
---
# Backend
apiVersion: v1
kind: Service
metadata:
  name: patchmon-backend
  namespace: patchmon
spec:
  selector:
    app: patchmon-backend
  ports:
    - name: http
      port: 3001
      targetPort: 3001
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: patchmon-backend
  namespace: patchmon
spec:
  replicas: 1
  selector:
    matchLabels:
      app: patchmon-backend
  template:
    metadata:
      labels:
        app: patchmon-backend
    spec:
      # NEW: fetch the real agent scripts before the app starts
      initContainers:
        - name: fetch-agent-scripts
          image: curlimages/curl:8.10.1
          imagePullPolicy: IfNotPresent
          command: ["sh","-c"]
          args:
            - >
              set -euo pipefail;
              mkdir -p /work;
              cd /work;
              echo "[init] downloading PatchMon agent scripts...";
              curl -fsSL
                https://raw.githubusercontent.com/PatchMon/PatchMon/main/agents/patchmon-agent.sh
                -o patchmon-agent.sh;
              curl -fsSL
                https://raw.githubusercontent.com/PatchMon/PatchMon/main/agents/patchmon_install.sh
                -o patchmon_install.sh;
              chmod +x patchmon-agent.sh patchmon_install.sh;
              echo "[init] done."
          volumeMounts:
            - name: agent-files
              mountPath: /work
              subPath: agents    # same subfolder we present to the app

      containers:
        - name: backend
          image: ghcr.io/9technologygroup/patchmon-backend:latest
          envFrom:
            - configMapRef: { name: patchmon-config }
            - secretRef:    { name: patchmon-db-secret }
          env:
            - name: DATABASE_URL
              valueFrom: { secretKeyRef: { name: patchmon-db-secret, key: DATABASE_URL } }
          ports:
            - containerPort: 3001
          volumeMounts:
            - name: agent-files
              mountPath: /app/agents
              subPath: agents    # the initContainer wrote the scripts here
          startupProbe:
            tcpSocket: { port: 3001 }
            failureThreshold: 30
            periodSeconds: 2
          readinessProbe:
            tcpSocket: { port: 3001 }
            periodSeconds: 5
          livenessProbe:
            tcpSocket: { port: 3001 }
            initialDelaySeconds: 10
            periodSeconds: 10
      volumes:
        - name: agent-files
          persistentVolumeClaim:
            claimName: patchmon-agents-pvc
---
# Frontend
apiVersion: v1
kind: Service
metadata:
  name: patchmon-frontend
  namespace: patchmon
spec:
  type: LoadBalancer
  loadBalancerIP: 172.16.23.39
  selector:
    app: patchmon-frontend
  ports:
    - name: http
      port: 80
      targetPort: 3000
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: patchmon-frontend
  namespace: patchmon
spec:
  replicas: 1
  selector:
    matchLabels:
      app: patchmon-frontend
  template:
    metadata:
      labels:
        app: patchmon-frontend
    spec:
      containers:
        - name: frontend
          image: ghcr.io/9technologygroup/patchmon-frontend:latest
          env:
            # Make nginx template point to the backend Service, not "backend"
            - name: BACKEND_HOST
              value: patchmon-backend
            - name: BACKEND_PORT
              value: "3001"
            # If your image uses URL vars instead:
            # - name: API_URL
            #   value: http://patchmon-backend:3001
            # - name: BACKEND_URL
            #   value: http://patchmon-backend:3001
          ports:
            - containerPort: 3000
          readinessProbe:
            tcpSocket: {port: 3000}
            periodSeconds: 5
          livenessProbe:
            tcpSocket: {port: 3000}
            initialDelaySeconds: 10
            periodSeconds: 10
